############################################
#### 13/10
############################################
- implémentation lecture d'instance.
- choix basique de la matrice d'adjacence pour représenter le graphe.
- validité vérifiée par le print du nombre d'edges versus la somme des 1 de la matrice
- average time of 0.0215 on 300 loads of brock200_2.col
- tests on scipy sparse matrix structures:
    The size of the sparse structure CSR seems interesting as compared to base adjacency matrix on bigger
    graphs (the size of CSR being discussed as the size of the class as well as the three main sub_arrays indices, indptr and
    data that are underlying) :
    Nom du graphe  Taille de CSR  Taille de adjacency
    brock200_2.col 1188 40128
    dsjc125.1.col 888 15753
    random-10.col 428 228
    random-100.col 788 10128
    random-40.col 548 1728
    random-70.col 668 5028

- Then made sparse construction directly from instance file rather than adjacency
-> Need to compare time for creations

############################################
#### 14/10
############################################
- compared time of sparse versus adjacency
- should we store everything as booleans ?
- building neighbourhoods is doable, but will eventually explode in terms
of complexity
- for n=200, building V_3 already takes 5E-2s, for 19900 neighbours
Possibles heuristics:
    - choose starting nodes (biggest degrees ?) and grow from it a maximal clique (not maximum) -> linear
    - il y a des algos en m^(3/2) pour les triangles
    - https://en.wikipedia.org/wiki/Clique_problem#Finding_a_single_maximal_clique : trouver un unique triangle ou pas d'existence
    peut se faire en encore mieux
- ajout calcul du degré dans la construction des données
- Idée d'heuristique perso : ranger les sommets par deg décroissant et tenter de construire une clique comme ça.

############################################
#### 15/10
############################################
- What we are looking for is a sub matrix with only ones except for the diagonal that is made of 0, is it usable ?
- Done with most basic heuristic
    Amelioration : If at some point the remaining degrees are less than the number
    of elements in the clique, no more node can be added. Very slight time gain.
- Done a dynamic version of basic heuristic, strangely it is faster and less
 efficient ??
 - added randomized versions where at each step we take one of the k possible candidates. For now k is arbitrarely set at deg_max // 2
 What value of k should be taken ?

############################################
#### 16/10
############################################
- Found interesting paper : https://www.researchgate.net/publication/341273157_Randomized_heuristic_for_the_maximum_clique_problem
The idea of descending degrees seems to be valid and can be worked on.
- On other instances, we see that, quite naturally, adding some randomness can yield better solutions, but of course not always.

############################################
#### 17/10
############################################
- worked on performance of random base heuristic

############################################
#### 18/10
############################################
- the problem we have here is that our neighbours will have either
0 or 1 as a delta for the objective, which makes it hard to discriminate
between them.
- première méta : faire un vns de base où on retire k noeuds de la clique et on refait une descente à partir de là.
- voisinage V_i(x) = retirer i noeuds de la clique x
- base idea : remove nodes and add others back with biggest degrees first. -> doesn't work
because we are always rebuilding the same clique.
